#!/bin/sh

# M122 Backup Script
# -------------------
# Gruppe: Studer
# - Lian Studer
# - Kris Huber
# -------------------
# Datum: 29. Nov 2021
# -------------------

# Notiz: Dieses Skript kann nur mit einer POSIX-Compliant Shell, 
# wie z.Bsp Bash oder Zsh verwendet werden.

# Pfad des aktuellen Skripts (backup.sh)
SCRIPT_PATH=${0%/*}

SOURCE_PATH="$SCRIPT_PATH/../topSrc"
BACKUP_PATH="$SCRIPT_PATH/../backSrc"


# Hilfe-Text, der angezeigt wird, falls ungültige Argumente eingegeben werden
USAGE_TEXT="backup [-h] -s <source> -d <dest> -p"

# Unix-Getopt Argument Parser
# Befehle:
# -h | --help    : Zeigt Hilfe Text an
# -s | --source  : Source Ordner 
# -d | --dest    : Backup Ordner
# -p | --pretend : Generiert eine Log-Datei, ohne die Dateien zu verschieben. (Dry Run)
VALID_ARGS=$(getopt -o "hs:d:p" --long "help,source:,dest:,pretend" -- "$@")

# Überprüft, ob die Ausführung von 'getopt' bei der Definition von VALID_ARGS erfolgreich war.
if [[ $? -ne 0 ]]; then
    exit 1
fi

eval set -- $VALID_ARGS
while [ : ]; do
    case "$1"  in
        -h | --help)
            echo $USAGE_TEXT
            shift
            ;;
        -s | --source)
            echo "$2"
            shift 2
            ;;
        -d | --dest)
            echo "$2"
            shift 2
            ;;
        --) shift;
            break
            ;;
    esac
done

# Create the backup folder
mkdir $BACKUP_PATH    

# Create log file
logfile=$(date '+%Y%m%d_%H%M_Log_Backup.txt')
touch $logfile
printf "Time\t\tEvent\t\tSource\t\tDestination\t\tStatus\n"

function write_log() {
    time=$1
    event=$2
    source=$3
    destination=$4

    printf "$1\t\t$2\t\t$3\t\t$4\n" >> $logfile
}


# Recursive backup function
function backup() {
    for x in $SOURCE_PATH/*; do
        echo "Backing up $x"
        write_log date "File Copy" x "$dest"
        [[ -f "${x}" ]] && cp "${x}" ../
        [[ -d "${x}" ]] && cd "${x}" && backup
        cd ..
    done
}

